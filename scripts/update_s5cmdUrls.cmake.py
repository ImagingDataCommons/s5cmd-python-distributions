#!usr/bin/env python3
from __future__ import annotations

import argparse
import re
from pathlib import Path
from urllib.request import urlopen

FILENAME_LOOKUP = {
    "linux32": "Linux-32bit.tar.gz",
    "linux64": "Linux-64bit.tar.gz",
    "linuxarm64": "Linux-arm64.tar.gz",
    "linuxppc64le": "Linux-ppc64le.tar.gz",
    "macos64": "macOS-64bit.tar.gz",
    "macosarm64": "macOS-arm64.tar.gz",
    "win32": "Windows-32bit.zip",
    "win64": "Windows-64bit.zip",
    "winarm64": "Windows-arm64.zip",
}
VERSION_RE = r"^s5cmd_([\d\.]+)_"
TEXT_RE = r"\# The section.+\n\# Do not edit this[\S\s]+\# The section.+\n\# Do not edit this.+\n"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Update s5cmd files and hashes in `s5cmdUrls.cmake`.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-c",
        "--checksum-file",
        type=str,
        help="Path or URL to the checksum file",
        required=True,
    )
    parser.add_argument(
        "-s",
        "--s5cmd-file",
        type=str,
        help="Path to the s5cmd file",
        default=Path(__file__).parents[1].joinpath("s5cmdUrls.cmake").as_posix(),
    )
    return parser.parse_args()


def read_checksum_text(path: str) -> str:
    if path.startswith("http"):
        response = urlopen(path)
        return response.read().decode("utf-8")

    _path = Path(path)
    if not _path.exists() or not _path.is_file():
        msg = f"Checksum file `{_path}` does not exist."
        raise FileNotFoundError(msg)
    return _path.read_text(encoding="utf-8")


def generate_cmake_text(text: str) -> str:
    checksums = [line.split() for line in text.rstrip("\n").split("\n")]

    version = re.search(VERSION_RE, checksums[0][1]).group(1)
    if version is None:
        msg = f"Cannot find version in {checksums[0][1]}"
        raise ValueError(msg)

    output_lines = [
        "# The section below is auto-generated by scripts/update_s5cmdUrls.cmake.py",
        "# Do not edit this section directly.",
        "",
        f'set(version "{version}")',
        "",
    ]

    for shortname, postfix in FILENAME_LOOKUP.items():
        hash_ = None
        for c in checksums:
            _filename = f"s5cmd_{version}_{postfix}"
            if _filename == c[1]:
                hash_ = c[0]
                break
        if hash_ is None:
            msg = f"Cannot find hash for `{_filename}` in {checksums}"
            raise ValueError(msg)

        output_lines.append(
            f"set({shortname}_filename".ljust(26) + f'"s5cmd_${{version}}_{postfix}")'
        )
        output_lines.append(f"set({shortname}_sha256".ljust(26) + f'"{hash_}")')
        output_lines.append("")

    output_lines.append(
        "# The section above is auto-generated by scripts/update_s5cmdUrls.cmake.py"
    )
    output_lines.append("# Do not edit this section directly.")
    output_lines.append("")

    return "\n".join(output_lines)


def overwrite_cmake_file(text: str, path: str) -> None:
    _path = Path(path)
    if not _path.exists() or not _path.is_file():
        msg = f"File `{_path}` does not exist."
        raise FileNotFoundError(msg)

    cmake_text = _path.read_text(encoding="utf-8")
    if not re.search(TEXT_RE, cmake_text):
        msg = f"Unable to find text in `{_path}`. Please check the regex."
        raise ValueError(msg)

    replaced_text = re.sub(TEXT_RE, text, cmake_text)
    _path.write_text(replaced_text, encoding="utf-8")

    print(f"Checksum file `{_path}` updated.")  # noqa: T201


def main():
    args = parse_args()
    text = read_checksum_text(args.checksum_file)
    cmake_text = generate_cmake_text(text)
    overwrite_cmake_file(cmake_text, args.s5cmd_file)


if __name__ == "__main__":
    main()
